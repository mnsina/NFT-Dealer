// SPDX-License-Identifier: MIT

pragma solidity ^0.8.3;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/utils/ERC721Holder.sol";

contract BasicNFT is ERC721, ERC721Holder {

// 0) Variables declaration:

string public Instructions = "Tokens represent stocks of an "
                             "NFT art broker firm. initially there are "
                             "100 unissued stocks with a unit price of "
                             "0.01 ethers.";
                             
address public Founder;
address public CFO;
address public CEO;
address public Enterprise;

uint public Available_Stocks=100;
address[] public Shareholders;

struct NFT_Bid{
    ERC721 NFT;
    uint NFT_Id;
    uint NFT_Price;
}

NFT_Bid[] public NFT_Enterprise_Bids;

uint TokenCount=0;

// 1) Firm construction:

constructor() ERC721("NFT Dealer", ":)") {

Founder = msg.sender;
CFO = msg.sender;
CEO = msg.sender;
Enterprise = address(this);
Available_Stocks=100;    

}

// 2) Contract Functions:

// 2.0) Buy firm stocks:

function Buy_Share() external payable {
require(msg.value == 0.01 ether, "Share value is 0.01 ethers");
require(Available_Stocks >= 1, "No more stocks available");
TokenCount=TokenCount+1;
_mint(msg.sender, TokenCount); 
 Available_Stocks=Available_Stocks-1;
 Shareholders.push(msg.sender);
} 

// 2.1) Pay dividends:

function Dividends_Pay(uint Amount) external payable {
 require(Amount <= 1 ether, "Maximum amount is 1 ether");
 require(msg.sender==CFO, "This function is only for the CFO of the firm");
 for (uint i=0; i<100-Available_Stocks; i++){
 payable(ownerOf(i+1)).transfer(Amount);
}}

// 2.2) Cash Balances:

function Cash_Firm() external view returns(uint) {
    return(address(this).balance);
}

function Cash_Personal() public view returns(uint) {
    return(msg.sender.balance);
}

// 2.3) NFT Balances:

function NFT_Balance_Firm(ERC721 Contract_NFT) external view returns(uint) {
    return(Contract_NFT.balanceOf(Enterprise));
}

function NFT_Balance_Personal(ERC721 Contract_NFT) public view returns(uint) {
     return(Contract_NFT.balanceOf(msg.sender));
}

// 2.4) Change executives:

function Change_CFO(address NewCFO) public {
    require(msg.sender==Founder, "This function is only for the Founder of the firm");
    CFO=NewCFO;
}

function Change_CEO(address NewCEO) public {
    require(msg.sender==Founder, "This function is only for the Founder of the firm");
    CEO=NewCEO;
}

// 2.5) Buy/Sell NFT Art:

function NFT_Client_Donate(ERC721 Contract_NFT, uint Id) public payable {
     Contract_NFT.safeTransferFrom(msg.sender, Enterprise, Id);
}

function NFT_Client_Buy(ERC721 Contract_NFT, uint Id, uint Bid) external payable {
     //require(Contract_NFT.ownerOf(Id)==msg.sender, "Not the owner of the NFT Token");
     require(Contract_NFT==NFT_Enterprise_Bids[Bid].NFT, "Error on NFT address");
     require(Id==NFT_Enterprise_Bids[Bid].NFT_Id, "Error on NFT ID");
     require(msg.value==NFT_Enterprise_Bids[Bid].NFT_Price, "Error on NFT price");
     Contract_NFT.approve(CEO, Id);
     Contract_NFT.safeTransferFrom(Enterprise, msg.sender, Id);
}

function NFT_CEO_Bid_New(ERC721 Contract_NFT, uint Id, uint Price) public {
    require(msg.sender==CEO, "This function is only for the CEO of the firm");
    NFT_Enterprise_Bids.push(NFT_Bid(Contract_NFT, Id, Price));
}

// 3) End Contract:


}
